// Code generated by ArduinoML

// Buzz function definition
void buzz(int targetPin, long frequency, long length) {
  if (!frequency) {
    digitalWrite(targetPin, LOW);
    delay(length);
  }
  else { 
   long delayValue = 1000000 / frequency / 2; // calculate the delay value between transitions
    // 1 second's worth of microseconds, divided by the frequency, then split in half since
    // there are two phases to each cycle
    long numCycles = frequency * length / 1000; // calculate the number of cycles for proper timing
    // multiply frequency, which is really cycles per second, by the number of seconds to
    // get the total number of cycles to produce
    for (long i = 0; i < numCycles; i++) { // for the calculated length of time…
        digitalWrite(targetPin, HIGH); // write the buzzer pin high to push out the diaphram
        delayMicroseconds(delayValue); // wait for the calculated delay value
        digitalWrite(targetPin, LOW); // write the buzzer pin low to pull back the diaphram
        delayMicroseconds(delayValue); // wait again or the calculated delay value
    }
  }
}

// BuzzAndLight function definition
void buzzAndLight(int buzzer, long frequency, long length, int leds[], int ledStates[], int nLeds, char matrix[], int matrixSize, int current) {
  for (int i = 0; i < nLeds; i++) {
    digitalWrite(leds[i], ledStates[i]); 
  }
  Serial.write(" ");
  if (!frequency) {
    digitalWrite(buzzer, LOW);
    delay(length);
  }
  else { 
  	if (matrixSize > 0) {
		Serial.write(matrix[current]);
	}
   long delayValue = 1000000 / frequency / 2; // calculate the delay value between transitions
    // 1 second's worth of microseconds, divided by the frequency, then split in half since
    // there are two phases to each cycle
    long numCycles = frequency * length / 1000; // calculate the number of cycles for proper timing
    // multiply frequency, which is really cycles per second, by the number of seconds to
    // get the total number of cycles to produce
    for (long i = 0; i < numCycles; i++) { // for the calculated length of time…
        digitalWrite(buzzer, HIGH); // write the buzzer pin high to push out the diaphram
        delayMicroseconds(delayValue); // wait for the calculated delay value
        digitalWrite(buzzer, LOW); // write the buzzer pin low to pull back the diaphram
        delayMicroseconds(delayValue); // wait again or the calculated delay value
    }
  }
  for (int i = 0; i < nLeds; i++) {
    digitalWrite(leds[i], LOW); 
  }
  
}
// Structural concepts
void setup() {
    pinMode(9, OUTPUT);
    pinMode(12, OUTPUT);
    pinMode(11, OUTPUT);
    pinMode(8, INPUT);
    pinMode(2, INPUT);
}

// Behavioral concepts
long time = 0; long debounce = 200;

void state_off() {
    digitalWrite(9, LOW);
    digitalWrite(12, LOW);
    boolean guard = millis() - time > debounce;
    if ((digitalRead(8) == HIGH ) && guard ) {
        time = millis(); state_on();
    }
    else { state_off(); }
}

void state_on() {
    digitalWrite(9, LOW);
    digitalWrite(12, HIGH);
    int tempo = 132; // refactor
    // Here comes the music \o/
    static int buzzer = 9;
    static int melody[] = { 2637,2349,2637,2349,2349,1976,2349,1976,2349,1976,1760,1760,1568,1760,1568,0, };
    static int rythm[] = { 2,4,8,4,8,8,8,8,8,8,4,2,4,8,8,4, };
    static int size = 16;
    static int current = 0;
    // Here comes the light
    static int leds[] = { 12,11, };
    static int nLeds = 2;
    static int ledStates[] = { HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,LOW, };
    static int currentLedStates[] = { HIGH,LOW, };
    static char matrix[] = { 'Y','M','C','A',' ','D','E','R','P',' ',' ','Y','M','C','A','!', };
    static int matrixSize = 16
;
    
    //Serial.println(current);
    // to calculate the note duration, take one second
    // divided by the note type.
    //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
    int totalDuration = 240000 / tempo / rythm[current];
    int noteDuration = totalDuration * 9 / 10;
    int delayDuration = totalDuration * 1 / 10;

    buzzAndLight(buzzer, melody[current], noteDuration, leds, currentLedStates, nLeds, matrix, matrixSize, current);
    delay(delayDuration);
    // updating iterators
    current = (current + 1) % size;
    for (int i = 0; i < nLeds; i++) {
        currentLedStates[i] = ledStates[current + size * i];    }
    boolean guard = millis() - time > debounce;
    if ((digitalRead(8) == HIGH ) && guard ) {
        time = millis(); state_mario();
    }
    else { state_on(); }
}

void state_mario() {
    digitalWrite(9, LOW);
    digitalWrite(12, HIGH);
    int tempo = 20 + analogRead(2)/(1023/280.0);
    // Here comes the music \o/
    static int buzzer = 9;
    static int melody[] = { 2637,2349,2637,2349,2349,1976,2349,1976,2349,1976,1760,1760,1568,1760,1568,0, };
    static int rythm[] = { 2,4,8,4,8,8,8,8,8,8,4,2,4,8,8,4, };
    static int size = 16;
    static int current = 0;
    // Here comes the light
    static int leds[] = { 12, };
    static int nLeds = 1;
    static int ledStates[] = { HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW,HIGH,LOW, };
    static int currentLedStates[] = { HIGH, };
    static char matrix[] = { 'Y','M','C','A',' ','D','E','R','P',' ',' ','Y','M','C','A','!', };
    static int matrixSize = 16
;
    
    //Serial.println(current);
    // to calculate the note duration, take one second
    // divided by the note type.
    //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
    int totalDuration = 240000 / tempo / rythm[current];
    int noteDuration = totalDuration * 9 / 10;
    int delayDuration = totalDuration * 1 / 10;

    buzzAndLight(buzzer, melody[current], noteDuration, leds, currentLedStates, nLeds, matrix, matrixSize, current);
    delay(delayDuration);
    // updating iterators
    current = (current + 1) % size;
    for (int i = 0; i < nLeds; i++) {
        currentLedStates[i] = ledStates[current + size * i];    }
    boolean guard = millis() - time > debounce;
    if ((digitalRead(8) == HIGH ) && guard ) {
        time = millis(); state_off();
    }
    else { state_mario(); }
}


void loop() { Serial.begin(9600); state_off(); } // Entering initial state
